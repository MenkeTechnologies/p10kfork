#compdef p10k

__p10k_getpart(){

    local -AU reply
    local -aU keys resparts partsDir partsFinal
    local -a parts
    local k v inputCnt resCnt suff strip magic premagic equals starter
    local line side elem
    local resline resside reselem response

    starter=''
    equals=$1
    magic='*'

    set -x
    parts=( ${(s:/:)${PREFIX//\\\*//*/}} )
    line="${parts[1]}"
    side="${parts[2]}"
    elem="${parts[3]}"
    inputCnt=$#parts

    if (( inputCnt > 2 )); then
        _message "no more /"
        return 1
    fi

    [[ $line != '' ]] && premagic="$line/"
    [[ $side != '' ]] && premagic="$premagic$side/"
    if [[ $premagic == '' ]]; then
        magic="*"
        starter=""
    else
        magic="$premagic*"
        starter="$premagic"

    fi

    sleep 2
    set +x
    p10k display -a $magic
    set -x

    keys=( ${(uk)reply} )

    for k in ${keys[@]};do

        resparts=( ${(s:/:)k} )
        resline=${resparts[1]}
        resside=${resparts[2]}
        reselem=${resparts[3]}

        resCnt=$#resparts
        [[ $premagic != '' ]] && resp="$premagic" || resp=''

        resp="$resp${resparts[ $((inputCnt + 1)) ]}"

        if (( (inputCnt + 1) == resCnt )); then
            partsFinal+=( "$resp$equals" )
        else
            partsDir+=( "$resp/" )
        fi
    done

    if (( inputCnt == 2 )); then
        partsFinal+=( "$premagic*$equals" )
    elif (( inputCnt < 2 )); then
        partsDir+=( "$starter*/" )
    fi
    set +x
    _wanted p10k-segment-final expl segmentfinal compadd -a partsFinal
    _wanted p10k-segment-dir expl segmentdir compadd -a partsDir
}
__p10k_partpattern(){
    __p10k_getpart ""

}

__p10k_partpattern_state(){

    local -aU state=(
        'show:the part is displayed'
        'hide:the part is not displayed'
        'print:the part is printed in precmd'
    )

    if compset -P '*='; then
        _describe -t p10k-state 'p10k-state' state
    else
        __p10k_getpart "="
    fi

}

__p10k_display(){

    local arguments

    arguments=(
        '(-)-a[Populate array `reply` with states of prompt parts]:part-pattern:__p10k_partpattern'
        '(: -)-r[Redisplay prompt]'
        '(-)*:part-pattern:__p10k_partpattern_state'
    )

    _arguments -S -s $arguments && return 0

}

__p10k_segment(){

  arguments=(
    '-t[segment main content; will undergo prompt expansion]:text'
    '-i[segment icon; default is empty]:icon'
    '-r[icon is a symbolic reference that needs to be resolved]'
    '+r[icon is already resolved and should be printed literally; for example,⭐]'
    '-b[background color; for example, empty value means]:bg'
    '-f[foreground color; for example, empty value means]:fg'
    '-s:segment state for the purpose of applying styling options]:state'
    '-c[if empty after parameter expansion and process substitution]:condition'
    '-e[segment main content will undergo parameter expansion and process]'
    '+e[segment main content should not undergo parameter expansion and process]'
    '(- :)-h[print this help message]'
    )

    _arguments -S -s $arguments && return 0

}

function _p10k(){

    local arguments verb
    local curcontext=$curcontext state line ret=0 __p10k_commands

    __p10k_commands=(
        'configure:run interactive configuration wizard'
        'reload:reload configuration'
        'segment:print a user-defined prompt segment'
        'display:show, hide or toggle prompt parts'
        'help:print this help message'
    )

    arguments=(
        '1:p10k subcommand:->verb'
        '*:: :->args'
    )

    _arguments -S -s $arguments && return 0

    case $state in
        verb)
            _describe -t p10k-commands "p10k verbs" __p10k_commands && ret=0
            ;;
        args)
            verb=$words[1]
            curcontext="${curcontext%:*:*}:p10k-$verb:"
            case $verb in
                configure)
                    _message 'no more arguments'
                    ret=1
                    ;;
                reload)
                    _message 'no more arguments'
                    ret=1
                    ;;
                segment)
                    __p10k_segment
                    ret=$?
                    ;;
                display)
                    __p10k_display
                    ret=$?
                    ;;
                help)
                    if (( $#words > 2)); then
                        _message 'no more arguments'
                        ret=1
                    else
                        _describe -t p10k-commands "p10k verbs" __p10k_commands && ret=0
                    fi
                    ;;
                *)
                    _message 'unknown p10k command'
                    ret=1
                    ;;
            esac
            ;;
    esac

    return $ret
}

_p10k "$@"
